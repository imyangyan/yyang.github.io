<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Array的变化侦测</title>
    <url>/2021/01/19/Array%E7%9A%84%E5%8F%98%E5%8C%96%E4%BE%A6%E6%B5%8B/</url>
    <content><![CDATA[<p>为什么Array的侦测方式与Object的不同，因为Object使用getter/setter实现的，而如果使用Array原型上的方法来改变数组的内容就不能触发getter/setter。</p>
<h2 id="如何追踪变化"><a href="#如何追踪变化" class="headerlink" title="如何追踪变化"></a>如何追踪变化</h2><p>用一个拦截器覆盖Array.prototype,那么在用户使用push等操作的时候就能得到通知实现追踪了。</p>
<h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><p>拦截器就是一个和Array.prototype一样的Object，里面包含的属性一模一样，只不过这个Object中某些能够改变数组自身内容的方法是我们处理的。<br>Array原型中可以改变数组自身内容的方法有7个：push、pop、shift、unshift、splice、sort和reverse。<br>实现代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arrayProto = <span class="built_in">Array</span>.prototype</span><br><span class="line"><span class="keyword">const</span> arrayMethods = <span class="built_in">Object</span>.create(arrayProto)</span><br><span class="line"></span><br><span class="line">;[</span><br><span class="line">  <span class="string">&#x27;push&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;pop&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;shift&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;unshift&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;splice&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;sort&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;reverse&#x27;</span></span><br><span class="line">]</span><br><span class="line">.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">method</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 缓存原始方法</span></span><br><span class="line">  <span class="keyword">const</span> original = arrayProto[method]</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(arrayMethods, method, &#123;</span><br><span class="line">    value: <span class="function"><span class="keyword">function</span> <span class="title">mutator</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> original.apply(<span class="built_in">this</span>, args)</span><br><span class="line">    &#125;,</span><br><span class="line">    enumerable: <span class="literal">false</span>,</span><br><span class="line">    writable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="使用拦截器覆盖Array原型"><a href="#使用拦截器覆盖Array原型" class="headerlink" title="使用拦截器覆盖Array原型"></a>使用拦截器覆盖Array原型</h2><p>想要拦截器生效就要用它去覆盖Array.prototype，但是不能直接覆盖，因为这样会污染全局的Array。<br>将一个数据转换成响应式的需要通过Observer，所以只需要在Observer中使用拦截器覆盖那些即将被转换成响应式的Array类型数据的原型就好了：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">  <span class="title">constructor</span> (<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.value = value</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">      value.__proto__ = arrayMethods <span class="comment">// 新增</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.walk(value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="将拦截器方法挂载到数组的属性上"><a href="#将拦截器方法挂载到数组的属性上" class="headerlink" title="将拦截器方法挂载到数组的属性上"></a>将拦截器方法挂载到数组的属性上</h2><p>Vue在如果不能使用__proto__情况下，句直接将arrayMethods身上的这些方法设置到被侦测的数组上：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// __porto__ 是否可用</span></span><br><span class="line"><span class="keyword">const</span> hasProto = <span class="string">&#x27;__proto__&#x27;</span> <span class="keyword">in</span> &#123;&#125;</span><br><span class="line"><span class="keyword">const</span> arrayKeys = <span class="built_in">Object</span>.getOwnPropertyNames(arrayMethods)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">  <span class="title">constructor</span> (<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.value = value</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">      <span class="comment">// 修改</span></span><br><span class="line">      <span class="keyword">const</span> augment = hasProto</span><br><span class="line">       ? protoAugment</span><br><span class="line">       : copyAugment</span><br><span class="line">      augment(value, arrayMethods, arrayKeys)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.walk(value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">protoAugment</span> (<span class="params">target, src, keys</span>) </span>&#123;</span><br><span class="line">  target.__proto__ = src</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copyAugment</span> (<span class="params">target,src, keys</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keys.length; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> key = keys[i]</span><br><span class="line">    def(target, key, src[key])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="如何收集依赖"><a href="#如何收集依赖" class="headerlink" title="如何收集依赖"></a>如何收集依赖</h2><p>Array的依赖和Object一样，也在defineReactive中收集：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span> (<span class="params">data, key, val</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> val === <span class="string">&#x27;object&#x27;</span>) <span class="keyword">new</span> Observer(val)</span><br><span class="line">  <span class="keyword">let</span> dep = <span class="keyword">new</span> Dep()</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(data, key, &#123;</span><br><span class="line">    enumberable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      dep.depend()</span><br><span class="line">      <span class="comment">// 这里收集Array的依赖</span></span><br><span class="line">      <span class="keyword">return</span> val</span><br><span class="line">    &#125;,</span><br><span class="line">    set: <span class="function"><span class="keyword">function</span> (<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (val === newVal) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      dep.notify()</span><br><span class="line">      val = newVal</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以，Array在getter中收集依赖，在拦截器中触发依赖。</p>
<h2 id="依赖列表存在哪儿"><a href="#依赖列表存在哪儿" class="headerlink" title="依赖列表存在哪儿"></a>依赖列表存在哪儿</h2><p>Vue把Array的依赖存放在了Observer中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">  <span class="title">constructor</span> (<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.value = value</span><br><span class="line">    <span class="built_in">this</span>.dep = <span class="keyword">new</span> Dep() <span class="comment">// 新增</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">      value.__proto__ = arrayMethods <span class="comment">// 新增</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.walk(value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>数组在getter中收集依赖，在拦截器中触发依赖，所以这个依赖的保存位置就必须在getter和拦截器中都可以访问到。<br>所以将依赖保存在Observer实例上，是因为在getter中可以访问到Observer实例，同时在Array拦截器中也可以访问到Observer实例。</p>
<h2 id="收集依赖"><a href="#收集依赖" class="headerlink" title="收集依赖"></a>收集依赖</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span> (<span class="params">data, key, val</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// if (typeof val === &#x27;object&#x27;) new Observer(val)</span></span><br><span class="line">  <span class="keyword">let</span> childOb = observe(val) <span class="comment">// 修改</span></span><br><span class="line">  <span class="keyword">let</span> dep = <span class="keyword">new</span> Dep()</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(data, key, &#123;</span><br><span class="line">    enumberable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      dep.depend()</span><br><span class="line">      <span class="comment">// 这里收集Array的依赖</span></span><br><span class="line">      <span class="keyword">if</span> (childOb) &#123;</span><br><span class="line">        childOb.dep.depend()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> val</span><br><span class="line">    &#125;,</span><br><span class="line">    set: <span class="function"><span class="keyword">function</span> (<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (val === newVal) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      dep.notify()</span><br><span class="line">      val = newVal</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 尝试为value创建一个 Observer 实例</span></span><br><span class="line"><span class="comment"> * 如果创建成功，直接返回创建的 Observer 实例</span></span><br><span class="line"><span class="comment"> * 如果 value 已经存在一个 Observer 实例， 则直接返回它</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observe</span> (<span class="params">value, asRootData</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!isObject(value)) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> ob</span><br><span class="line">  <span class="keyword">if</span> (hasOwn(value, <span class="string">&#x27;__ob__&#x27;</span>) ** value.__ob__ <span class="keyword">instanceof</span> Observer) &#123;</span><br><span class="line">    ob = value.__ob__</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ob = <span class="keyword">new</span> Observer(value)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ob</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="在拦截器中获取Observer实例"><a href="#在拦截器中获取Observer实例" class="headerlink" title="在拦截器中获取Observer实例"></a>在拦截器中获取Observer实例</h2><p>因为Array拦截器是对原型的一种封装，所以可以在拦截器中访问到this（当前正在被操作的数组）<br>而dep保存在Observer中，所以需要在this上读到Observer实例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 工具函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">def</span> (<span class="params">obj, key, val, enumberable</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, val, &#123;</span><br><span class="line">    value: val,</span><br><span class="line">    enumerable: !!enumberable,</span><br><span class="line">    writeable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">  <span class="title">constructor</span> (<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.value = value</span><br><span class="line">    <span class="built_in">this</span>.dep = <span class="keyword">new</span> Dep()</span><br><span class="line">    def(value, <span class="string">&#x27;__ob__&#x27;</span>, <span class="built_in">this</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">      <span class="keyword">const</span> augment = hasProto</span><br><span class="line">        ? protoAugment</span><br><span class="line">        : copyAugment</span><br><span class="line">      augment(value, arrayMethods, arrayKeys)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.walk(value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码在value上新增一个不可枚举的属性__ob__，这个属性就是当前Observer的实例。<br>这样就可以通过数组数据的__ob__属性拿到Observer实例，然后就可以拿到__ob__上的dep。<br>__ob__的作用不仅仅是为了在拦截器中访问Observer实例，还可以用来标记当前value是否已经被Observer转换成了响应式数据。<br>当value身上被标记了__ob__之后，就可以通过value.__ob__来访问Observer实例。如果是Array拦截器，因为拦截器是原型方法，所以通过this.__ob__来访问Observer实例。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">;[</span><br><span class="line">  <span class="string">&#x27;push&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;pop&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;shift&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;unshift&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;splice&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;sort&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;reverse&#x27;</span></span><br><span class="line">]</span><br><span class="line">.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">method</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 缓存原始方法</span></span><br><span class="line">  <span class="keyword">const</span> original = arrayProto[method]</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(arrayMethods, method, &#123;</span><br><span class="line">    value: <span class="function"><span class="keyword">function</span> <span class="title">mutator</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> ob = <span class="built_in">this</span>.__ob__ <span class="comment">// 新增</span></span><br><span class="line">      <span class="keyword">return</span> original.apply(<span class="built_in">this</span>, args)</span><br><span class="line">    &#125;,</span><br><span class="line">    enumerable: <span class="literal">false</span>,</span><br><span class="line">    writable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>在mutator函数里通过this.__ob__来获取Observer实例。</p>
<h2 id="向数组的依赖发送通知"><a href="#向数组的依赖发送通知" class="headerlink" title="向数组的依赖发送通知"></a>向数组的依赖发送通知</h2><p>当侦测到数组发生变化时，会向依赖发送通知。只需要在Observer实例中拿到dep属性，然后直接发送通知就可以了：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">;[</span><br><span class="line">  <span class="string">&#x27;push&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;pop&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;shift&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;unshift&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;splice&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;sort&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;reverse&#x27;</span></span><br><span class="line">]</span><br><span class="line">.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">method</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 缓存原始方法</span></span><br><span class="line">  <span class="keyword">const</span> original = arrayProto[method]</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(arrayMethods, method, &#123;</span><br><span class="line">    value: <span class="function"><span class="keyword">function</span> <span class="title">mutator</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> result = original.apply(<span class="built_in">this</span>, args)</span><br><span class="line">      <span class="keyword">const</span> ob = <span class="built_in">this</span>.__ob__</span><br><span class="line">      ob.dep.notify()</span><br><span class="line">      <span class="keyword">return</span> result</span><br><span class="line">    &#125;,</span><br><span class="line">    enumerable: <span class="literal">false</span>,</span><br><span class="line">    writable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>通过调用ob.dep.notify()去通知依赖（Watcher）数据发生了变化。</p>
<h2 id="侦测数组中元素的变化"><a href="#侦测数组中元素的变化" class="headerlink" title="侦测数组中元素的变化"></a>侦测数组中元素的变化</h2><p>在Observer中新增一些处理，让它可以将Array也转换成响应式的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">  <span class="title">constructor</span> (<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.value = value</span><br><span class="line">    <span class="built_in">this</span>.dep = <span class="keyword">new</span> Dep()</span><br><span class="line">    def(value, <span class="string">&#x27;__ob__&#x27;</span>, <span class="built_in">this</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">      <span class="built_in">this</span>.observeArray(value)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.walk(value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 侦测 Array 中的每一项</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  observeArray (items) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; items.length; i++) &#123;</span><br><span class="line">      observe(items[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="侦测新增元素的变化"><a href="#侦测新增元素的变化" class="headerlink" title="侦测新增元素的变化"></a>侦测新增元素的变化</h2><p>数组中的一些方法可以新增数组内容的，如push，而新增的内容也需要转换成响应式来侦测变化，只要能获取新增的元素并使用Observer来侦测它们就行了。</p>
<p>修改拦截器，如果操作数组的方法是push、unshift、splice（可以新增数组元素的方法），则把参数中新增的元素拿过来，用Observer来侦测：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">;[</span><br><span class="line">  <span class="string">&#x27;push&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;pop&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;shift&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;unshift&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;splice&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;sort&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;reverse&#x27;</span></span><br><span class="line">]</span><br><span class="line">.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">method</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 缓存原始方法</span></span><br><span class="line">  <span class="keyword">const</span> original = arrayProto[method]</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(arrayMethods, method, &#123;</span><br><span class="line">    value: <span class="function"><span class="keyword">function</span> <span class="title">mutator</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> result = original.apply(<span class="built_in">this</span>, args)</span><br><span class="line">      <span class="keyword">const</span> ob = <span class="built_in">this</span>.__ob__</span><br><span class="line">      <span class="keyword">let</span> inserted</span><br><span class="line">      <span class="keyword">switch</span> (method) &#123;</span><br><span class="line">        cash <span class="string">&#x27;push&#x27;</span>:</span><br><span class="line">        cash <span class="string">&#x27;unshift&#x27;</span>:</span><br><span class="line">          inserted = args</span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">        cash <span class="string">&#x27;splice&#x27;</span>:</span><br><span class="line">          inserted = args.slice(<span class="number">2</span>)</span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (inserted) ob.observeArray(inserted)</span><br><span class="line">      ob.dep.notify()</span><br><span class="line">      <span class="keyword">return</span> result</span><br><span class="line">    &#125;,</span><br><span class="line">    enumerable: <span class="literal">false</span>,</span><br><span class="line">    writable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="关于Array的问题"><a href="#关于Array的问题" class="headerlink" title="关于Array的问题"></a>关于Array的问题</h2><p>对Array的变化侦测是通过拦截原型的方式实现的，正因为这种实现方式，有些数组操作Vue是拦截不到的，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.list[<span class="number">0</span>] = <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>即直接修改数组中的元素，无法侦测到数组的变化，所以并不会触发re-render或watch等。<br>例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.list.length = <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>这个清空数组的操作也无法侦测到数组的变化，所以也不会触发re-render或watch等。</p>
]]></content>
      <categories>
        <category>深入浅出Vue. js</category>
      </categories>
  </entry>
  <entry>
    <title>HTML</title>
    <url>/2021/03/02/HTML/</url>
    <content><![CDATA[<h2 id="如何理解HTML语义化？"><a href="#如何理解HTML语义化？" class="headerlink" title="如何理解HTML语义化？"></a>如何理解HTML语义化？</h2><p>HTML语义化就是使用正确的标签，例如段落使用p标签，标题使用h1标签，文章使用article标签，视频使用video标签等等。<br>从前端发展历史来看，最开始是后台开发人员使用table布局，容易造成table嵌套，后期维护困难；然后是美工人员使用div+css布局，不够语义化，不知道各个div之间的区别；然后是前端阶段使用正确的标签来完成页面。</p>
<h2 id="meta-viewport-是做什么用的，怎么写？"><a href="#meta-viewport-是做什么用的，怎么写？" class="headerlink" title="meta viewport 是做什么用的，怎么写？"></a>meta viewport 是做什么用的，怎么写？</h2><p>是让当前viewport的宽度等于设备的宽度，同时不允许用户手动缩放。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=0&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="用过哪些HTML5标签？"><a href="#用过哪些HTML5标签？" class="headerlink" title="用过哪些HTML5标签？"></a>用过哪些HTML5标签？</h2><p>常见的内容相关的标签：header main footer article等等<br>功能相关的：</p>
<ul>
<li>canvas<br>作用：Canvas API提供了一个通过JavaScript和HTML的canvas标签来绘制图形的方式。它可以用于动画、游戏画面、数据可视化、图片编辑以及实时视频处理等方面。<br>基础示例：<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">&quot;canvas&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> canvas = <span class="built_in">document</span>.getELementById(<span class="string">&#x27;canvas&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> ctx = canvas.getContext(<span class="string">&#x27;2d&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ctx.fillStyle = <span class="string">&#x27;green&#x27;</span></span><br><span class="line">ctx.fillRect(<span class="number">10</span>, <span class="number">10</span>, <span class="number">150</span>, <span class="number">100</span>)</span><br></pre></td></tr></table></figure></li>
<li>video<br>作用：在HTML中嵌入媒体播放器<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Simple video example --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">src</span>=<span class="string">&quot;videofile.ogg&quot;</span> <span class="attr">autoplay</span> <span class="attr">poster</span>=<span class="string">&quot;posterimage.jpg&quot;</span>&gt;</span></span><br><span class="line">  抱歉，您的浏览器不支持内嵌视频，不过不用担心，你可以 <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;videofile.ogg&quot;</span>&gt;</span>下载<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  并用你喜欢的播放器观看!</span><br><span class="line"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Video with subtitles --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">src</span>=<span class="string">&quot;foo.ogg&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">track</span> <span class="attr">kind</span>=<span class="string">&quot;subtitles&quot;</span> <span class="attr">src</span>=<span class="string">&quot;foo.en.vtt&quot;</span> <span class="attr">srclang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">label</span>=<span class="string">&quot;English&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">track</span> <span class="attr">kind</span>=<span class="string">&quot;subtitles&quot;</span> <span class="attr">src</span>=<span class="string">&quot;foo.sv.vtt&quot;</span> <span class="attr">srclang</span>=<span class="string">&quot;sv&quot;</span> <span class="attr">label</span>=<span class="string">&quot;Svenska&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>audio<br>作用：在文档中嵌入音频<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Simple audio playback --&gt;</span></span><br><span class="line">&lt;audio</span><br><span class="line">  src=&quot;AudioTest.ogg&quot;</span><br><span class="line">  autoplay&gt;</span><br><span class="line">  Your browser does not support the <span class="tag">&lt;<span class="name">code</span>&gt;</span>audio<span class="tag">&lt;/<span class="name">code</span>&gt;</span> element.</span><br><span class="line"><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="什么是H5？"><a href="#什么是H5？" class="headerlink" title="什么是H5？"></a>什么是H5？</h2>H5其实是一种解决方案，是一个炫酷的移动端onepage网站的解决方案，不只是包括HTML5，也包含了全部的前端基本知识。</li>
</ul>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
  </entry>
  <entry>
    <title>Object的变化侦测</title>
    <url>/2021/01/02/Object%E7%9A%84%E5%8F%98%E5%8C%96%E4%BE%A6%E6%B5%8B/</url>
    <content><![CDATA[<p>在vue2中，Object 和 Array 的变化侦测是采用的不同的处理方式。</p>
<h2 id="什么是变化侦测"><a href="#什么是变化侦测" class="headerlink" title="什么是变化侦测"></a>什么是变化侦测</h2><p>Vue.js会自动通过状态生成DOM，并将其输出到页面上显示出来，这个过程叫做渲染。Vue.js的渲染过程是声明试的，通过模版来描述状态与DOM之间的映射关系。<br>通常，在运行时应用内部的状态不断变化，此时需要不断的重新渲染。这时如何确定状态中发生了什么变化？<br>变化侦测就是用来解决这个问题的，它分为两种类型：一种是“推”（push），另一种是“拉”（pull）。<br>Angular和React中的变化侦测都属于“拉”，当状态发生变化时，只知道状态发生了变化，不知道哪个状态发生了变化，然后会发送一个信号告诉框架，框架接收到信号后会进行一个暴力比对来找出哪些DOM节点需要重新渲染。这在Angular中是脏检查的流程，在React中使用的是虚拟DOM。<br>而Vue.js的变化侦测属于“推”。当状态发生变化时，Vue.js立刻就知道了，而且在一定程度上知道哪些状态变了。因此，它知道的信息更多，也就可以进行更细粒度的更新。<br>所谓更细粒度的更新，就是说：假如有一个状态绑定了多个依赖，每个依赖表示一个具体的DOM节点，那么当这个状态发生变化时，向这个状态的所有依赖发送通知，让他们进行DOM更新操作。相比较而言，“拉”的粒度是最粗的。<br>但是它也有一定的代价，因为粒度越细，每个状态绑定的依赖就越多，依赖追踪在内存上的开销就会越大。因此，Vue.js 2.0开始，它引入了虚拟DOM，将粒度调整为中等粒度，即一个状态所绑定的依赖不在是具体的DOM节点，而是一个组件。这样状态变化后，会通知到组件，组件内部再使用虚拟DOM进行比对。这可以大大降低依赖数量，从而降低依赖追踪所消耗的内存。<br>Vue.js之所以能随意调整粒度，本质上还要归功于变化侦测。因为“推”类型的变化侦测可以随意调整粒度。</p>
<h2 id="如何追踪变化"><a href="#如何追踪变化" class="headerlink" title="如何追踪变化"></a>如何追踪变化</h2><p>在JS中有两种方法可以侦测到变化：Object.defineProperty和ES6的Proxy。<br>Vue.js 2.0考虑到Proxy在浏览器中的支持度不理想，所以使用的是Object.defineProperty来实现的变化侦测。<br>使用Object.defineProperty可以写出这样的代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span> (<span class="params">data, key, val</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(data, key, &#123;</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> val</span><br><span class="line">    &#125;,</span><br><span class="line">    set: <span class="function"><span class="keyword">function</span> (<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (val === newVal) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      val = newVal</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数defineReactive用来对Object.defineProperty进行封装。该函数定义一个响应式数据。每当从data的key中读取数据时，get函数被触发；每当往data的key中设置数据时，set函数被触发。</p>
<h2 id="如何收集依赖"><a href="#如何收集依赖" class="headerlink" title="如何收集依赖"></a>如何收集依赖</h2><p>目的是在数据变化时通知到使用了该数据的地方，所以可以想到，需要先收集依赖，等到属性发生变化时，再把之前收集的依赖循环触发。<br>总结：在getter中收集依赖，在setter中触发依赖。</p>
<h2 id="依赖收集在哪里"><a href="#依赖收集在哪里" class="headerlink" title="依赖收集在哪里"></a>依赖收集在哪里</h2><p>首先想到每个key都有一个数组用来储存当前key的依赖。假设依赖是一个函数，保存在window.target上。<br>实现一个Dep类,专门用来管理依赖。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">  <span class="title">constructor</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.subs = []</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  addSub (sub) &#123;</span><br><span class="line">    <span class="built_in">this</span>.subs.push(sub)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  removeSub (sub) &#123;</span><br><span class="line">    remove(<span class="built_in">this</span>.subs, sub)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  depend () &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">window</span>.target) &#123;</span><br><span class="line">      <span class="built_in">this</span>.addSun(<span class="built_in">window</span>.target)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  notify () &#123;</span><br><span class="line">    <span class="keyword">const</span> subs = <span class="built_in">this</span>.subs.slice()</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; subs.length; i++) &#123;</span><br><span class="line">      subs[i].update()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">remove</span> (<span class="params">arr, item</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (arr.length) &#123;</span><br><span class="line">    <span class="keyword">const</span> index = arr.indexOf(item)</span><br><span class="line">    <span class="keyword">if</span> (index &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> arr.splice(index, <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后改造一下defineReactive：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span> (<span class="params">data, key, val</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> dep = <span class="keyword">new</span> Dep()  <span class="comment">// 增加</span></span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(data, key, &#123;</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      dep.depend() <span class="comment">// 增加</span></span><br><span class="line">      <span class="keyword">return</span> val</span><br><span class="line">    &#125;,</span><br><span class="line">    set: <span class="function"><span class="keyword">function</span> (<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (val === newVal) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      val = newVal</span><br><span class="line">      dep.notify() <span class="comment">// 增加</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>依赖收集到哪了？收集到了Dep中。</p>
<h2 id="依赖是谁"><a href="#依赖是谁" class="headerlink" title="依赖是谁"></a>依赖是谁</h2><p>在上面代码中，我们收集的依赖是window.target，那么它到底是什么？到底要收集谁？<br>收集谁，换句话说就是通知谁。<br>我们要通知用到数据的地方，而使用这个数据的地方有很多，类型还不一样，有可能是模板，有可能是用户写的watch，这是需要抽象一个能集中处理这些情况的类，然后我们在依赖收集阶段只收集这个封装好的类的实例，通知也只通知它，它在负责通知其他地方。<br>我们把这个类叫做Watcher，所以依赖是Watcher。</p>
<h2 id="什么是Watcher"><a href="#什么是Watcher" class="headerlink" title="什么是Watcher"></a>什么是Watcher</h2><p>Watcher是一个中介角色，数据变化时通知它，然后它再通知其他地方。<br>关于Watcher，先看一个经典的使用方式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">vm.$watch(<span class="string">&#x27;a.b.c&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">newVal, oldVal</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这段代码表示data.a.b.c属性发生变化时，触发第二个参数中的函数。<br>怎么实现这个功能呢？只要把这个Wachter实例添加到data.a.b.c属性的Dep中就行了。然后当data.a.b.c的值发生变化时，通知Watcher，然后Watcher再执行参数中的这个回调函数。<br>实现以下代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">  <span class="title">constructor</span> (<span class="params">vm, expOrFn, cb</span>) &#123;</span><br><span class="line">    <span class="comment">// 执行this.getter(),就可以读取data.a.b.c的内容</span></span><br><span class="line">    <span class="built_in">this</span>.getter = parsePath(expOrFn)</span><br><span class="line">    <span class="built_in">this</span>.cb = cb</span><br><span class="line">    <span class="built_in">this</span>.value = <span class="built_in">this</span>.get()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  get () &#123;</span><br><span class="line">    <span class="built_in">window</span>.target = <span class="built_in">this</span></span><br><span class="line">    <span class="keyword">let</span> value = <span class="built_in">this</span>.getter.call(<span class="built_in">this</span>.vm, <span class="built_in">this</span>.vm)</span><br><span class="line">    <span class="built_in">window</span>.target = <span class="literal">undefined</span></span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  update () &#123;</span><br><span class="line">    <span class="keyword">const</span> oldValue = <span class="built_in">this</span>.value</span><br><span class="line">    <span class="built_in">this</span>.value = <span class="built_in">this</span>.get()</span><br><span class="line">    <span class="built_in">this</span>.cb.call(<span class="built_in">this</span>.vm, <span class="built_in">this</span>.value, oldValue)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 解析简单路径</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> bailRE = <span class="regexp">/[^\w.$]/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parsePath</span> (<span class="params">path</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (bailRE.test(path)) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> segments = path.split(<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; segments.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!obj) <span class="keyword">return</span></span><br><span class="line">      obj = obj[segments[i]]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="递归侦测所有key"><a href="#递归侦测所有key" class="headerlink" title="递归侦测所有key"></a>递归侦测所有key</h2><p>上面已经实现了侦测数据中的某一个属性，我们希望把数据中的所有属性都侦测到，所以要封装一个Observer类。这个类的作用是将一个数据内的所有属性都转换成getter/setter的形式，然后去追踪它们的变化：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Observer类会附加到每一个被侦测的object上。</span></span><br><span class="line"><span class="comment"> * 一旦被附加上，Observer会将object的所有属性转换成getter/setter的形式</span></span><br><span class="line"><span class="comment"> * 来收集属性的依赖，并且当属性发生变化时会通知这些依赖 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">  <span class="title">constructor</span> (<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.value = value</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">      <span class="built_in">this</span>.walk(value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** </span></span><br><span class="line"><span class="comment">   * walk会将每一个属性都转换成getter/setter的形式来侦测变化</span></span><br><span class="line"><span class="comment">   * 这个方法只有在数据类型为Object是被调用</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  walk (obj) &#123;</span><br><span class="line">    <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(obj)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keys.length; i++) &#123;</span><br><span class="line">      defineReactive(obj, keys[i], obj[keys[i]])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span> (<span class="params">data, key, val</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 新增，递归子属性</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> val === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">new</span> Observer(val)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> dep = <span class="keyword">new</span> Dep()</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(data, key, &#123;</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      dep.depend()</span><br><span class="line">      <span class="keyword">return</span> val</span><br><span class="line">    &#125;,</span><br><span class="line">    set: <span class="function"><span class="keyword">function</span> (<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (val === newVal) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      val = newVal</span><br><span class="line">      dep.notify()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面定义了一个observer类，它用来将正常的object转换成被侦测的object。<br>只要将一个object传到Observer中，那么这个object就会变成响应式的object。</p>
<h2 id="关于Object的问题"><a href="#关于Object的问题" class="headerlink" title="关于Object的问题"></a>关于Object的问题</h2><p>Vue.js通过Object.defineProperty将对象的key转换成getter/setter的形式来追踪变化，但getter/setter只能追踪一个数据是否被修改，无法追踪新增属性和删除属性，为了解决这个问题，Vue.js提供了两个API——vm.$set和vm.$delete。</p>
]]></content>
      <categories>
        <category>深入浅出Vue. js</category>
      </categories>
  </entry>
  <entry>
    <title>VNode</title>
    <url>/2021/01/26/VNode/</url>
    <content><![CDATA[<h2 id="什么是VNode"><a href="#什么是VNode" class="headerlink" title="什么是VNode"></a>什么是VNode</h2><p>在Vue中有一个VNode类，使用它可以实例华不同类型的vnode实例，而不同类型的vnode实例各自表示不同类型的DOM元素。<br>例如，DOM元素有元素节点、文本节点和注释节点等，vnode实例也会对应着有元素节点、文本节点和注释节点等。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VNode</span> </span>&#123;</span><br><span class="line">  <span class="title">constructor</span> (<span class="params"></span></span><br><span class="line"><span class="params">    tag,</span></span><br><span class="line"><span class="params">    data,</span></span><br><span class="line"><span class="params">    children,</span></span><br><span class="line"><span class="params">    text,</span></span><br><span class="line"><span class="params">    elm,</span></span><br><span class="line"><span class="params">    context,</span></span><br><span class="line"><span class="params">    componentOptions,</span></span><br><span class="line"><span class="params">    asyncFactory</span></span><br><span class="line"><span class="params">  </span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.tag = tag</span><br><span class="line">    <span class="built_in">this</span>.data = data</span><br><span class="line">    <span class="built_in">this</span>.children = children</span><br><span class="line">    <span class="built_in">this</span>.text = text</span><br><span class="line">    <span class="built_in">this</span>.elm = elm</span><br><span class="line">    <span class="built_in">this</span>.ns = <span class="literal">undefined</span></span><br><span class="line">    <span class="built_in">this</span>.context = context</span><br><span class="line">    <span class="built_in">this</span>.fnContext = <span class="literal">undefined</span></span><br><span class="line">    <span class="built_in">this</span>.fnOptions = <span class="literal">undefined</span></span><br><span class="line">    <span class="built_in">this</span>.fnScopeId = <span class="literal">undefined</span></span><br><span class="line">    <span class="built_in">this</span>.key = data &amp;&amp; data.key</span><br><span class="line">    <span class="built_in">this</span>.componentOptions = componentOptions</span><br><span class="line">    <span class="built_in">this</span>.componentInstance = <span class="literal">undefined</span></span><br><span class="line">    <span class="built_in">this</span>.parent = <span class="literal">undefined</span></span><br><span class="line">    <span class="built_in">this</span>.raw = <span class="literal">false</span></span><br><span class="line">    <span class="built_in">this</span>.isStatic = <span class="literal">false</span></span><br><span class="line">    <span class="built_in">this</span>.isRootInsert = <span class="literal">true</span></span><br><span class="line">    <span class="built_in">this</span>.isComment = <span class="literal">false</span></span><br><span class="line">    <span class="built_in">this</span>.isCloned = <span class="literal">false</span></span><br><span class="line">    <span class="built_in">this</span>.isOnce = <span class="literal">false</span></span><br><span class="line">    <span class="built_in">this</span>.asyncFactory = asyncFactory</span><br><span class="line">    <span class="built_in">this</span>.asyncMeta = <span class="literal">undefined</span></span><br><span class="line">    <span class="built_in">this</span>.isAsyncPlaceholder = <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// DEPRECATED: alias for componentInstance for backwards compat.</span></span><br><span class="line">  <span class="comment">/* istanbul ignore next */</span></span><br><span class="line">  get child () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.componentInstance</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单的说，vnode可以理解成节点描述对象，它描述来应该怎样去创建真实的DOM节点。<br>例如，tag表示一个元素节点的名称，text表示一个文本节点的文本，children表示子节点等。</p>
<h2 id="VNode的作用"><a href="#VNode的作用" class="headerlink" title="VNode的作用"></a>VNode的作用</h2><p>由于每次渲染视图时都是先创建vnode，然后使用它创建真实DOM插入到页面中，所以可以将上一次创建的vnode缓存起来，之后每当需要重新渲染视图时，将新创建的vnode和上一次缓存的vnode进行对比，查看它们之间有哪些不一样的地方，找出这些不一样的地方并基于此去修改真实的DOM。<br>Vue中当状态发生变化时，只通知到组件级别，然后组件内使用虚拟DOM来渲染视图，只要组件使用的众多状态中有一个发生了变化，那么整个组件就要重新渲染。如果组件只有一个节点发生了变化，那么这种方式明显会造成很大的性能浪费。因此，对vnode进行缓存，并将上一次缓存的vnode和当前新创建的vnode进行对比，只更新发生变化的节点就变得尤为重要。这也是vnode最重要的一个作用。</p>
<h2 id="VNode的类型"><a href="#VNode的类型" class="headerlink" title="VNode的类型"></a>VNode的类型</h2><p>vnode的类型有以下6中：</p>
<ul>
<li>注释节点</li>
<li>文本节点</li>
<li>元素节点</li>
<li>组件节点</li>
<li>函数式节点</li>
<li>克隆节点</li>
</ul>
<p>vnode就是JS中的一个对象，不同类型的vnode之间其实只是有效属性不同。因为当使用VNode类创建一个vnode时，通过参数为实例设置属性时，无效的属性会默认被赋值为undefined或false。对于vnode上的无效属性，直接忽略就好。</p>
<h3 id="注释节点"><a href="#注释节点" class="headerlink" title="注释节点"></a>注释节点</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> createEmptyVNode = <span class="function"><span class="params">text</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> node = <span class="keyword">new</span> VNode()</span><br><span class="line">  node.text = text</span><br><span class="line">  node.isComment = <span class="literal">true</span></span><br><span class="line">  <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个注释节点只有两个有效属性——text和isComment，其余属性全是默认的undefined和false。</p>
<h3 id="文本节点"><a href="#文本节点" class="headerlink" title="文本节点"></a>文本节点</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createTextVNode</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> VNode(<span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="built_in">String</span>(val))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个文本节点的有效属性只有一个text属性。</p>
<h3 id="克隆节点"><a href="#克隆节点" class="headerlink" title="克隆节点"></a>克隆节点</h3><p>克隆节点是将现有节点的属性复制到新节点中，让新创建的节点和被克隆节点的属性保持一致，从而实现克隆效果。它的作用是优化静态节点和插槽节点（slot node）。<br>以静态节点为例，当组件内某个状态发生变化后，当前组件会通过虚拟DOM重新渲染视图，静态节点因为它的内容不会改变，所以除了首次渲染需要执行渲染函数获取vnode之外，后续更新不需要执行渲染函数重新生成vnode。因此，这时就会使用创建克隆节点的方法将vnode克隆一份，使用克隆节点进行渲染。这样就不需要重新执行渲染函数生成新的静态节点的vnode，从而提升一定程度的性能。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">cloneVNode</span> (<span class="params">vnode: VNode</span>): <span class="title">VNode</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> cloned = <span class="keyword">new</span> VNode(</span><br><span class="line">    vnode.tag,</span><br><span class="line">    vnode.data,</span><br><span class="line">    <span class="comment">// #7975</span></span><br><span class="line">    <span class="comment">// clone children array to avoid mutating original in case of cloning</span></span><br><span class="line">    <span class="comment">// a child.</span></span><br><span class="line">    vnode.children &amp;&amp; vnode.children.slice(),</span><br><span class="line">    vnode.text,</span><br><span class="line">    vnode.elm,</span><br><span class="line">    vnode.context,</span><br><span class="line">    vnode.componentOptions,</span><br><span class="line">    vnode.asyncFactory</span><br><span class="line">  )</span><br><span class="line">  cloned.ns = vnode.ns</span><br><span class="line">  cloned.isStatic = vnode.isStatic</span><br><span class="line">  cloned.key = vnode.key</span><br><span class="line">  cloned.isComment = vnode.isComment</span><br><span class="line">  cloned.fnContext = vnode.fnContext</span><br><span class="line">  cloned.fnOptions = vnode.fnOptions</span><br><span class="line">  cloned.fnScopeId = vnode.fnScopeId</span><br><span class="line">  cloned.asyncMeta = vnode.asyncMeta</span><br><span class="line">  cloned.isCloned = <span class="literal">true</span></span><br><span class="line">  <span class="keyword">return</span> cloned</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>克隆现有节点时，只需要将现有节点的属性全部复制到新节点中即可。<br>克隆节点和被克隆节点之间的唯一区别是isCloned属性，克隆节点的isCloned为true，被克隆节点的原始节点的isClone为false。</p>
<h3 id="元素节点"><a href="#元素节点" class="headerlink" title="元素节点"></a>元素节点</h3><p>元素节点通常会存在以下4种有效属性：</p>
<ul>
<li>tag：就是一个节点的名称，例如p、ul、li等</li>
<li>data：该属性包含了一些节点上的数据，比如attrs、class和style等</li>
<li>children：当前节点的子节点列表</li>
<li>context：它是当前组件的Vue实例</li>
</ul>
<h3 id="组件节点"><a href="#组件节点" class="headerlink" title="组件节点"></a>组件节点</h3><p>组件节点和元素节点类似，有以下两个独有的属性。</p>
<ul>
<li>componentOptions：就是组件节点的选项参数，其中包含propsData、tag和children等信息。 </li>
<li>componentInstance：组件的实例，也就是Vue实例。事实上，在Vue中，每个组件都是一个Vue实例。</li>
</ul>
<h3 id="函数式节点"><a href="#函数式节点" class="headerlink" title="函数式节点"></a>函数式节点</h3><p>函数式节点和组件节点类似，它有两个独有的属性functionalContenthe functionalOptions。</p>
]]></content>
      <categories>
        <category>深入浅出Vue. js</category>
      </categories>
  </entry>
  <entry>
    <title>patch</title>
    <url>/2021/02/03/patch/</url>
    <content><![CDATA[<p>虚拟DOM的最核心部分就是patch，它可以将vnode渲染成真实的DOM。<br>patch也可以叫作patching算法，通过它渲染真实DOM时，并不是暴力覆盖原有DOM，而是比对新旧两个vnode之间有哪些不同，然后根据对比结果找出需要更新的节点进行更新。</p>
<h2 id="patch介绍"><a href="#patch介绍" class="headerlink" title="patch介绍"></a>patch介绍</h2><p>比对两个vnode之间的差异只是patch的一部分，这是手段，而不是目的。patch的目的其实是修改DOM节点，也可以理解为渲染视图。对现有DOM进行修改需要做三件事：</p>
<ul>
<li>创建新增的节点</li>
<li>删除已经废弃的节点</li>
<li>修改需要更新的节点<br>我们知道patch的过程中其实就是创建节点、删除节点和更新节点的过程，接下来主要讨论在什么情况下创建新节点，插入到什么位置；在什么情况下删除节点，删除哪个节点；在什么情况下修改节点，修改哪个节点等。</li>
</ul>
<h3 id="新增节点"><a href="#新增节点" class="headerlink" title="新增节点"></a>新增节点</h3><p>如果一个节点已经存在于DOM中，那就不需要重新创建一个同样的节点去替换已经存在的节点。事实上，只有那些因为状态的改变而新增的节点在DOM中并不存在时，我们才需要创建一个节点并插入到DOM中。<br>首先，新增节点的一个明显的场景就是，当oldVnode不存在而vnode存在时，就需要使用vnode生成真实的DOM元素并将其插入到视图中去。<br>这通常发生在首次渲染中。因为首次渲染时，DOM中不存在任何节点，所以oldVnode是不存在的。<br>当vnode和oldVnode完全不是同一个节点时，需要使用vnode生成真实的DOM元素并将其插入到视图中。</p>
<h3 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h3><p>当一个节点只在oldVnode中存在时，我们需要把它从DOM中删除。因为渲染视图时，需要以vnode为标准，所以vnode中不存在的节点有属于被废弃的节点，而被废弃的节点需要从DOM中删除。<br>当oldVnode与vnode完全不是同一个节点时，在DOM中需要使用vnode创建的新节点替换oldVnode所对应的旧节点，而替换过程是将新创建的DOM节点插入到旧节点的旁边，然后再将旧节点删除，从而完成替换过程。</p>
<h3 id="更新节点"><a href="#更新节点" class="headerlink" title="更新节点"></a>更新节点</h3><p>当新旧两个节点是相同的节点时，我们需要对这两个节点进行比较细致的比对，然后对oldVnode在视图中所对应的真实节点进行更新。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>通过前面的介绍，发现整个patch的过程并不复杂。当oldVnode不存在时，直接使用vnode渲染视图；当oldVnode和vnode都存在但并不是同一个节点时，使用vnode创建的DOM元素替换旧的DOM元素；当oldVnode和vnode是同一个节点时，使用更详细的对比操作真实的DOM节点进行更新。</p>
<h2 id="创建节点"><a href="#创建节点" class="headerlink" title="创建节点"></a>创建节点</h2><p>创建一个真实的DOM元素所需的信息都保存在vnode中，我们需要通过vnode来创建一个真实的DOM元素。前面也介绍来vnode是有类型的，所以在创建DOM元素时，最重要的事是根据vnode的类型来创建出相同类型的DOM元素，然后将DOM元素插入到视图中。<br>事实上，只有三种类型的节点会被创建并插入到DOM中：元素节点、注释节点和文本节点。<br>而要判断vnode是否是元素节点，只需要判断它是否具有tag属性即可。如果一个vnode具有tag属性，就认为它是元素节点。接着，我们就可以调用当前环境下的createElement方法来创建真实的元素节点。当一个元素节点被创建后，接下来要做的事情就是将它插入到指定的父节点中。<br>将元素渲染到视图的过程非常简单。只需要调用当前环境下的appendChild方法，就可以将一个元素插入到指定的父节点中。如果这个指定的父节点已经被渲染到视图，那么把元素插入到它的下面将会自动将元素渲染到视图。<br>其实创建元素节点还缺来一个步骤。元素节点通常都会有子节点，所以当一个元素节点被创建后，我们需要将它的子节点也创建出来并插入到这个刚创建出的节点下面。<br>创建子节点的过程是一个递归过程。vnode中的children属性保存了当前节点的所有子虚拟节点（child virtual node），所以只需要将vnode中的children属性循环一遍，将每个子虚拟节点都执行一遍创建元素的逻辑，就可以实现我们想要的功能。<br>创建子节点时，子节点的父节点就是当前刚创建出来的这个节点，所以子节点被创建后，会被插入到当前节点的下面。当所有子节点都创建完并插入到当前节点中之后，我们把当前节点插入到指定父节点的下面。如果这个指定父节点已经被渲染到视图中，那么将当前这个节点插入进去之后，会将当前节点（包括其子节点）渲染到视图中。<br>除了元素节点外，其实还要创建注释节点和文本节点。<br>在创建节点时，如果vnode中不存在tag属性，那么它可能会是另外两中节点：注释节点和文本节点。<br>当发现一个vnode的tag属性不存在时，我们可以用isComment属性来判断它是注释节点还是文本节点。如果是文本节点，则调用当前环境下的createTextNode方法来创建真实的文本节点并将其插入到指定的父节点中；如果是注释节点，则调用当前环境下的createComment方法来创建真实的注释节点并将其插入到指定的父节点中。</p>
<h2 id="删除节点-1"><a href="#删除节点-1" class="headerlink" title="删除节点"></a>删除节点</h2><p>删除节点的过程非常简单。在Vue中其实现逻辑如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeVnodes</span> (<span class="params">vnodes, startIdx, endIdx</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (; startIdx &lt;= endIdx; ++startIdx) &#123;</span><br><span class="line">    <span class="keyword">const</span> ch = vnodes[startIdx]</span><br><span class="line">    <span class="keyword">if</span> (isDef(ch)) &#123;</span><br><span class="line">      removeNode(ch.elm)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单来说，上面代码实现的功能是删除vnodes数组中从startIdx指定的位置到endIdx指定位置的内容。<br>reomveNode用于删除视图中的单个节点，而removeVnodes用于删除一组指定的节点。<br>removeNode实现逻辑如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> nodeOps = &#123;</span><br><span class="line">  removeChild (node, child) &#123;</span><br><span class="line">    node.removeChild(child)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeNode</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> parent = nodeOps.parentNode(el)</span><br><span class="line">  <span class="keyword">if</span> (isDef(parent)) &#123;</span><br><span class="line">    nodeOps.removeChild(parent, el)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码的逻辑是将当前元素从它的父节点中删除，其中nodeOps是对节点操作的封装。<br>将DOM元素操作方法进行封装涉及跨平台渲染的知识。</p>
<h2 id="更新节点-1"><a href="#更新节点-1" class="headerlink" title="更新节点"></a>更新节点</h2><h3 id="静态节点"><a href="#静态节点" class="headerlink" title="静态节点"></a>静态节点</h3><p>在更新节点时，首先需要判断新旧两个虚拟节点是否是静态节点，如果是，就不需要进行更新操作。<br>静态节点指的是那些一旦渲染到界面上之后，无论日后状态如何变化，都不会发生任何变化的节点。<br>例如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>静态节点<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面这个HTML就是一个静态节点，它不会因为状态的变化而发生变化。</p>
<h3 id="新虚拟节点有文本属性"><a href="#新虚拟节点有文本属性" class="headerlink" title="新虚拟节点有文本属性"></a>新虚拟节点有文本属性</h3><p>当新旧两个虚拟节点不是静态节点，并且有不同的属性时，要以新虚拟节点为准来更新视图。根据新节点是否有text属性，更新节点可以分为两种不同的情况。<br>如果新生成的虚拟节点有text属性，那么不论之前旧节点的子节点是什么，直接调用setTextContent来将视图中DOM节点的内容改为虚拟节点的text属性所保存的文字。<br>如果之前的旧节点也是文本，并且和新节点的文本相同，那么就不需要执行setTextContent方法来重复设置相同的文本。</p>
<h3 id="新虚拟节点无文本属性"><a href="#新虚拟节点无文本属性" class="headerlink" title="新虚拟节点无文本属性"></a>新虚拟节点无文本属性</h3><p>如果新创建的虚拟节点没有text属性，那么它就是一个元素节点。元素节点通常会有子节点，也就是children属性，但也有可能没有子节点，所以存在两中不同的情况。</p>
<h4 id="有children的情况"><a href="#有children的情况" class="headerlink" title="有children的情况"></a>有children的情况</h4><p>当新创建的虚拟节点有children属性时，其实还会有两种情况，那就是要看旧虚拟节点是否有children属性。<br>如果旧虚拟节点也有children属性，那么要对新旧两个虚拟节点的children进行一个更详细的对比并更新。更新children可能会移动某个子节点的位置，也有可能会删除或新增某个子节点。<br>如果旧节点没有children属性，那么说明旧虚拟节点要么是一个空标签，要么是有文本的文本节点。如果是文本节点，那么先把文本清空让它变成空标签，然后将新虚拟节点中的children挨个创建成真实的DOM元素节点并将其插入到视图中的DOM节点下面。</p>
<h4 id="无children的情况"><a href="#无children的情况" class="headerlink" title="无children的情况"></a>无children的情况</h4><p>当新创建的虚拟节点既没有text属性也没有children属性时，这说明这个新创建的节点是一个空节点，这是如果旧虚拟节点中有子节点就删除子节点，有文本就删除文本。最后达到视图中是空标签的目的</p>
]]></content>
      <categories>
        <category>深入浅出Vue. js</category>
      </categories>
  </entry>
  <entry>
    <title>变化侦测相关的API实现原理</title>
    <url>/2021/01/20/%E5%8F%98%E5%8C%96%E4%BE%A6%E6%B5%8B%E7%9B%B8%E5%85%B3%E7%9A%84API%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="vm-watch"><a href="#vm-watch" class="headerlink" title="vm.$watch"></a>vm.$watch</h2><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">vm.$watch( expOrFn, callback, [options] )</span><br></pre></td></tr></table></figure>
<p>参数：</p>
<ul>
<li>{string | Function} expOrFn</li>
<li>{Function | Object} callback</li>
<li>{Object} [options]<ul>
<li>{boolean} deep</li>
<li>{boolean} immediate<br>返回值：{Function} unwatch<br>用法：用于观察一个表达式或computed函数在Vue实例上的变化。回调函数调用时，会从参数得到新数据（new value）和旧数据（old value）。表达式只接受以点分隔的路径，例如a.b.c。如果是一个比较复杂的表达式，可以用函数代替表达式。<br>例如：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">vm.$watch(<span class="string">&#x27;a.b.c&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">newVal, oldVal</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 做点什么</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
vm.$watch返回一个取消观察函数，用来停止触发回调：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> unwatch = vm.$watch(<span class="string">&#x27;a&#x27;</span>, <span class="function">(<span class="params">newVal, oldVal</span>) =&gt;</span> &#123;&#125;)</span><br><span class="line"><span class="comment">// 之后取消观察</span></span><br><span class="line">unwatch()</span><br></pre></td></tr></table></figure>
最后简单介绍一下[options]的两个选项deep和immediate。</li>
</ul>
</li>
<li>deep。为了发现对象内部值的变化，可以在选项参数中指定deep: true：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">vm.$watch(<span class="string">&#x27;someObject&#x27;</span>, callback, &#123;</span><br><span class="line">  deep: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line">vm.someObject.nestedValue = <span class="number">123</span></span><br><span class="line"><span class="comment">// 回调函数将被触发</span></span><br></pre></td></tr></table></figure>
这里值得注意的是，监听数组的变动不需要这么做。</li>
<li>immediate。在选项参数中指定immediate: true,将立即以表达式的当前值触发回调：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">vm.$watch(<span class="string">&#x27;a&#x27;</span>, callback, &#123;</span><br><span class="line">  immediate: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 立即以 &#x27;a&#x27; 的当前值触发回调</span></span><br></pre></td></tr></table></figure>
<h3 id="watch内部原理"><a href="#watch内部原理" class="headerlink" title="watch内部原理"></a>watch内部原理</h3></li>
</ul>
<p>vm.$watch其实是对Watcher的一种封装，通过Watcher完全可以实现vm.$watch的功能，但是vm.$watch中的参数deep和immediate是Watcher没有的。下面看一看vm.$watch到底是怎么实现的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.prototype.$watch = <span class="function"><span class="keyword">function</span> (<span class="params">expOrFn, cb, options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> vm = <span class="built_in">this</span></span><br><span class="line">  options = options || &#123;&#125;</span><br><span class="line">  <span class="keyword">const</span> watcher = <span class="keyword">new</span> Watcher(vm, expOrFn, cb, options)</span><br><span class="line">  <span class="keyword">if</span> (options.immediate) &#123;</span><br><span class="line">    cb.call(vm, watcher.value)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">unwatchFn</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    watcher.teardown()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="deep参数的实现原理"><a href="#deep参数的实现原理" class="headerlink" title="deep参数的实现原理"></a>deep参数的实现原理</h3><p>Watcher想监听某个数据，就会触发某个数据收集依赖的逻辑，将自己收集进去，然后当它发生变化时，就会通知Watcher。要想实现deep的功能，就是除了要触发当前这个被监听数据的收集依赖的逻辑之外，还要把当前监听的这个值在内的所有子值都触发一遍收集依赖逻辑。这就可以实现当前这个依赖的所有子数据发生变化时，通知当前Watcher了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">  <span class="title">constructor</span> (<span class="params">vm, expOrFn, cb, options</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.vm = vm</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (options) &#123;</span><br><span class="line">      <span class="built_in">this</span>.deep = !!optiobs.deep</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.deep = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.deps = []</span><br><span class="line">    <span class="built_in">this</span>.depIds = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">    <span class="built_in">this</span>.getter = parsePath(expOrFn)</span><br><span class="line">    <span class="built_in">this</span>.cb = cb</span><br><span class="line">    <span class="built_in">this</span>.value = <span class="built_in">this</span>.get()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  get () &#123;</span><br><span class="line">    <span class="built_in">window</span>.target = <span class="built_in">this</span></span><br><span class="line">    <span class="keyword">let</span> value = <span class="built_in">this</span>.getter.call(vm, vm)</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.deep) &#123;</span><br><span class="line">      traverse(value)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">window</span>.target = <span class="literal">undefined</span></span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> seenObjects = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">traverse</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">  _traverse(val, seenObjects)</span><br><span class="line">  seenObjects.clear()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_traverse</span> (<span class="params">val, seen</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i, keys</span><br><span class="line">  <span class="keyword">const</span> isA = <span class="built_in">Array</span>.isArray(val)</span><br><span class="line">  <span class="keyword">if</span> ((isA &amp;&amp; !isObject(val)) || <span class="built_in">Object</span>.isFrozen(val)) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (val.__ob__) &#123;</span><br><span class="line">    <span class="keyword">const</span> depId = val.__ob__.dep.id</span><br><span class="line">    <span class="keyword">if</span> (seen.has(depId)) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    seen.add(depId)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (isA) &#123;</span><br><span class="line">    i = val.length</span><br><span class="line">    <span class="keyword">while</span> (i--) _traverse(val[i], seen)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    keys = <span class="built_in">Object</span>.keys(val)</span><br><span class="line">    i = keys.length</span><br><span class="line">    <span class="keyword">while</span> (i--) _traverse(val[keys[i]], seen)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="vm-set"><a href="#vm-set" class="headerlink" title="vm.$set"></a>vm.$set</h2><h3 id="用法-1"><a href="#用法-1" class="headerlink" title="用法"></a>用法</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">vm.$set(target, key, value )</span><br></pre></td></tr></table></figure>
<p>参数：</p>
<ul>
<li>{Object | Array} target</li>
<li>{string | number} key</li>
<li>{any} value<br>返回值： {Function} unwatch<br>用法：在object上设置一个属性，如果object是响应式的，Vue会保证属性被创建后也是响应式的，并且触发试图更新。这个方法主要用来避开Vue不能侦测属性被添加的限制。</li>
</ul>
<h3 id="Array的处理"><a href="#Array的处理" class="headerlink" title="Array的处理"></a>Array的处理</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">set</span> (<span class="params">target, key, val</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(target) &amp;&amp; isValidArrayIndex(key)) &#123;</span><br><span class="line">    target.length = <span class="built_in">Math</span>.max(target.length, key)</span><br><span class="line">    target.splice(key, <span class="number">1</span>, val)</span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当使用splice方法把val设置到target中的时候，数组拦截器会侦测到target发生了变化，并且自动帮助我们把这个新增的val转换成响应式的。</p>
<h3 id="key已经存在于target中"><a href="#key已经存在于target中" class="headerlink" title="key已经存在于target中"></a>key已经存在于target中</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">set</span> (<span class="params">target, key, val</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(target) &amp;&amp; isValidArrayIndex(key)) &#123;</span><br><span class="line">    target.length = <span class="built_in">Math</span>.max(target.length, key)</span><br><span class="line">    target.splice(key, <span class="number">1</span>, val)</span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 新增</span></span><br><span class="line">  <span class="keyword">if</span> (key <span class="keyword">in</span> target &amp;&amp; !(key <span class="keyword">in</span> <span class="built_in">Object</span>.prototype)) &#123;</span><br><span class="line">    target[key] = val</span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于key已经存在于target中，所以这个key已经被侦测了变化。直接修改就会自动向依赖发送通知。</p>
<h3 id="处理新增的属性"><a href="#处理新增的属性" class="headerlink" title="处理新增的属性"></a>处理新增的属性</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">set</span> (<span class="params">target, key, val</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(target) &amp;&amp; isValidArrayIndex(key)) &#123;</span><br><span class="line">    target.length = <span class="built_in">Math</span>.max(target.length, key)</span><br><span class="line">    target.splice(key, <span class="number">1</span>, val)</span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (key <span class="keyword">in</span> target &amp;&amp; !(key <span class="keyword">in</span> <span class="built_in">Object</span>.prototype)) &#123;</span><br><span class="line">    target[key] = val</span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 新增</span></span><br><span class="line">  <span class="keyword">const</span> ob = target.__ob__</span><br><span class="line">  <span class="keyword">if</span> (target._isVue || (ob &amp;&amp; ob.vmCount)) &#123;</span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!ob) &#123;</span><br><span class="line">    target[key] = val</span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line">  &#125;</span><br><span class="line">  defineReactive(ob.value, key, val)</span><br><span class="line">  ob.dep.notify()</span><br><span class="line">  <span class="keyword">return</span> val</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一步处理“target不能是Vue实例或Vue实例的根对象”的情况。<br>第二步处理target如果不为响应式数据，直接通过key和val在target上设置就行了。<br>第三步处理target为响应式数据，这种情况需要追踪这个新增属性的变化，用defineReactive将新增属性转换成getter/setter的形式，然后向target的依赖触发变化通知，并返回val。</p>
<h2 id="vm-delete"><a href="#vm-delete" class="headerlink" title="vm.$delete"></a>vm.$delete</h2><p>vm.$delete是为了解决使用delete关键字删除无法发现数据发生变化的问题。</p>
<h3 id="用法-2"><a href="#用法-2" class="headerlink" title="用法"></a>用法</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">vm.$delete(target, key)</span><br></pre></td></tr></table></figure>
<p>参数：</p>
<ul>
<li>{Object | Array} target</li>
<li>{string | number} key/index</li>
</ul>
<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">del</span> (<span class="params">target, key</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(target) &amp;&amp; isValidArrayIndex(key)) &#123;</span><br><span class="line">    target.length = <span class="built_in">Math</span>.max(target.length, key)</span><br><span class="line">    target.splice(key, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> ob = target.__ob__</span><br><span class="line"></span><br><span class="line">  <span class="comment">// target不能是Vue实例或Vue实例的根对象</span></span><br><span class="line">  <span class="keyword">if</span> (target._isVue || (ob &amp;&amp; ob.vmCount)) &#123;</span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果key不是target自身的属性，则终止程序继续执行</span></span><br><span class="line">  <span class="keyword">if</span> (!hasOwn(target, key)) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">delete</span> target[key]</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果ob不存在，则直接终止程序</span></span><br><span class="line">  <span class="keyword">if</span> (!ob) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  ob.dep.notify()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>深入浅出Vue. js</category>
      </categories>
  </entry>
  <entry>
    <title>实现Promise</title>
    <url>/2021/03/12/%E5%AE%9E%E7%8E%B0Promise/</url>
    <content><![CDATA[<h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><p>使用ES6的语法，构造一个类，通过实例化的方式返回promise对象，由于Promise已经存在，暂时命名为Deferred。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Deferred</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">callback</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> resolve = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// TODO</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> reject = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// TODO</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      callback(resolve, reject)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error)&#123;</span><br><span class="line">      reject(error)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>构造函数接收一个callback，调用callback时传入resolve、reject。</p>
<h2 id="Promise的状态"><a href="#Promise的状态" class="headerlink" title="Promise的状态"></a>Promise的状态</h2><p>Promise一共分为三个状态：pending、fulfilled、rejected。</p>
<ul>
<li>pending：等待中，这是Promise的初始状态<br><img src="/images/%E5%AE%9E%E7%8E%B0Promise/pending.png"></li>
<li>fulfilled：已结束，正常调用resolve的状态<br><img src="/images/%E5%AE%9E%E7%8E%B0Promise/fulfilled.png"></li>
<li>rejected：已拒绝，内部出现错误或者调用reject之后的状态<br><img src="/images/%E5%AE%9E%E7%8E%B0Promise/rejected.png"></li>
</ul>
<p>Promise在运行期间有一个状态，储存在[[PromiseState]]中。下面为Deferred添加状态：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基础变量的定义</span></span><br><span class="line"><span class="keyword">const</span> STATUS = &#123;</span><br><span class="line">  PENDING: <span class="string">&#x27;PENDING&#x27;</span>,</span><br><span class="line">  FULFILLED: <span class="string">&#x27;FULFILLED&#x27;</span>,</span><br><span class="line">  REJECTED: <span class="string">&#x27;REJECTED&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Deferred</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">callback</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.status = STATUS.PENDING</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> resolve = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// TODO</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> reject = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// TODO</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      callback(resolve, reject)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error)&#123;</span><br><span class="line">      reject(error)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="内部结果"><a href="#内部结果" class="headerlink" title="内部结果"></a>内部结果</h2><p>Promise内部还有个[[PromiseResult]]来暂存resolve/reject接受的值。<br><img src="/images/%E5%AE%9E%E7%8E%B0Promise/promiseResultResolve.png"><br><img src="/images/%E5%AE%9E%E7%8E%B0Promise/promiseResultReject.png"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基础变量的定义</span></span><br><span class="line"><span class="keyword">const</span> STATUS = &#123;</span><br><span class="line">  PENDING: <span class="string">&#x27;PENDING&#x27;</span>,</span><br><span class="line">  FULFILLED: <span class="string">&#x27;FULFILLED&#x27;</span>,</span><br><span class="line">  REJECTED: <span class="string">&#x27;REJECTED&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Deferred</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">callback</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.value = <span class="literal">undefined</span></span><br><span class="line">    <span class="built_in">this</span>.status = STATUS.PENDING</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> resolve = <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.value = value</span><br><span class="line">      <span class="comment">// TODO</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> reject = <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.value = reason</span><br><span class="line">      <span class="comment">// TODO</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      callback(resolve, reject)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error)&#123;</span><br><span class="line">      reject(error)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="储存回调"><a href="#储存回调" class="headerlink" title="储存回调"></a>储存回调</h2><p>使用Promise的时候，一般会调用promise对象的.then方法，在promise状态转为fulfilled或rejected的时候，拿到内部结果，然后做后续处理。<br>在构造函数中创建两个数组用来存储.then的回调。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基础变量的定义</span></span><br><span class="line"><span class="keyword">const</span> STATUS = &#123;</span><br><span class="line">  PENDING: <span class="string">&#x27;PENDING&#x27;</span>,</span><br><span class="line">  FULFILLED: <span class="string">&#x27;FULFILLED&#x27;</span>,</span><br><span class="line">  REJECTED: <span class="string">&#x27;REJECTED&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Deferred</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">callback</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.value = <span class="literal">undefined</span></span><br><span class="line">    <span class="built_in">this</span>.status = STATUS.PENDING</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.resolveQueue = []</span><br><span class="line">    <span class="built_in">this</span>.rejectQueue = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> resolve = <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.value = value</span><br><span class="line">      <span class="comment">// TODO</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> reject = <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.value = reason</span><br><span class="line">      <span class="comment">// TODO</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      callback(resolve, reject)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error)&#123;</span><br><span class="line">      reject(error)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="resolve与reject"><a href="#resolve与reject" class="headerlink" title="resolve与reject"></a>resolve与reject</h1><h2 id="修改状态"><a href="#修改状态" class="headerlink" title="修改状态"></a>修改状态</h2><p>resolve与reject在被调用的时候，会改变promise对象的状态，并且任一方法被调用后，另外方法不可被调用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基础变量的定义</span></span><br><span class="line"><span class="keyword">const</span> STATUS = &#123;</span><br><span class="line">  PENDING: <span class="string">&#x27;PENDING&#x27;</span>,</span><br><span class="line">  FULFILLED: <span class="string">&#x27;FULFILLED&#x27;</span>,</span><br><span class="line">  REJECTED: <span class="string">&#x27;REJECTED&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Deferred</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">callback</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.value = <span class="literal">undefined</span></span><br><span class="line">    <span class="built_in">this</span>.status = STATUS.PENDING</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.resolveQueue = []</span><br><span class="line">    <span class="built_in">this</span>.rejectQueue = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> called <span class="comment">// 用于判断状态是否被修改</span></span><br><span class="line">    <span class="keyword">const</span> resolve = <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (called) <span class="keyword">return</span></span><br><span class="line">      called = <span class="literal">true</span></span><br><span class="line">      <span class="built_in">this</span>.value = value</span><br><span class="line">      <span class="comment">// 修改状态</span></span><br><span class="line">      <span class="built_in">this</span>.status = STATUS.FULFILLED</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> reject = <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (called) <span class="keyword">return</span></span><br><span class="line">      called = <span class="literal">true</span></span><br><span class="line">      <span class="built_in">this</span>.value = reason</span><br><span class="line">      <span class="comment">// 修改状态</span></span><br><span class="line">      <span class="built_in">this</span>.status = STATUS.REJECTED</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      callback(resolve, reject)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error)&#123;</span><br><span class="line">      reject(error)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="调用回调"><a href="#调用回调" class="headerlink" title="调用回调"></a>调用回调</h2><p>修改状态之后，拿到结果的promise一般会调用then方法传入的回调</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基础变量的定义</span></span><br><span class="line"><span class="keyword">const</span> STATUS = &#123;</span><br><span class="line">  PENDING: <span class="string">&#x27;PENDING&#x27;</span>,</span><br><span class="line">  FULFILLED: <span class="string">&#x27;FULFILLED&#x27;</span>,</span><br><span class="line">  REJECTED: <span class="string">&#x27;REJECTED&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Deferred</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">callback</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.value = <span class="literal">undefined</span></span><br><span class="line">    <span class="built_in">this</span>.status = STATUS.PENDING</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.resolveQueue = []</span><br><span class="line">    <span class="built_in">this</span>.rejectQueue = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> called <span class="comment">// 用于判断状态是否被修改</span></span><br><span class="line">    <span class="keyword">const</span> resolve = <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (called) <span class="keyword">return</span></span><br><span class="line">      called = <span class="literal">true</span></span><br><span class="line">      <span class="built_in">this</span>.value = value</span><br><span class="line">      <span class="comment">// 修改状态</span></span><br><span class="line">      <span class="built_in">this</span>.status = STATUS.FULFILLED</span><br><span class="line">      <span class="comment">// 调用回调</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> fn <span class="keyword">of</span> <span class="built_in">this</span>.resolveQueue) &#123;</span><br><span class="line">        fn(<span class="built_in">this</span>.value)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> reject = <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (called) <span class="keyword">return</span></span><br><span class="line">      called = <span class="literal">true</span></span><br><span class="line">      <span class="built_in">this</span>.value = reason</span><br><span class="line">      <span class="comment">// 修改状态</span></span><br><span class="line">      <span class="built_in">this</span>.status = STATUS.REJECTED</span><br><span class="line">      <span class="comment">// 调用回调</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> fn <span class="keyword">of</span> <span class="built_in">this</span>.rejectQueue) &#123;</span><br><span class="line">        fn(<span class="built_in">this</span>.value)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      callback(resolve, reject)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error)&#123;</span><br><span class="line">      reject(error)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>promise.then中的回调会被放入微任务队列中，然后异步调用。<br>即使已经变成fulfilled状态的promise，传递给then()的函数也总是会被异步调用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="number">2</span>))</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>) <span class="comment">// 1, 2</span></span><br></pre></td></tr></table></figure>
<p>所以，需要将回调的调用放入异步队列，使用setTimeout来实现延迟调用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基础变量的定义</span></span><br><span class="line"><span class="keyword">const</span> STATUS = &#123;</span><br><span class="line">  PENDING: <span class="string">&#x27;PENDING&#x27;</span>,</span><br><span class="line">  FULFILLED: <span class="string">&#x27;FULFILLED&#x27;</span>,</span><br><span class="line">  REJECTED: <span class="string">&#x27;REJECTED&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Deferred</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">callback</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.value = <span class="literal">undefined</span></span><br><span class="line">    <span class="built_in">this</span>.status = STATUS.PENDING</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.resolveQueue = []</span><br><span class="line">    <span class="built_in">this</span>.rejectQueue = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> called <span class="comment">// 用于判断状态是否被修改</span></span><br><span class="line">    <span class="keyword">const</span> resolve = <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (called) <span class="keyword">return</span></span><br><span class="line">      called = <span class="literal">true</span></span><br><span class="line">      <span class="comment">// 异步调用</span></span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value</span><br><span class="line">        <span class="comment">// 修改状态</span></span><br><span class="line">        <span class="built_in">this</span>.status = STATUS.FULFILLED</span><br><span class="line">        <span class="comment">// 调用回调</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> fn <span class="keyword">of</span> <span class="built_in">this</span>.resolveQueue) &#123;</span><br><span class="line">          fn(<span class="built_in">this</span>.value)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> reject = <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (called) <span class="keyword">return</span></span><br><span class="line">      called = <span class="literal">true</span></span><br><span class="line">      <span class="comment">// 异步调用</span></span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = reason</span><br><span class="line">        <span class="comment">// 修改状态</span></span><br><span class="line">        <span class="built_in">this</span>.status = STATUS.REJECTED</span><br><span class="line">        <span class="comment">// 调用回调</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> fn <span class="keyword">of</span> <span class="built_in">this</span>.rejectQueue) &#123;</span><br><span class="line">          fn(<span class="built_in">this</span>.value)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      callback(resolve, reject)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error)&#123;</span><br><span class="line">      reject(error)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="then方法"><a href="#then方法" class="headerlink" title="then方法"></a>then方法</h2><p>then方法是能够进行链式调用的，所以then必须返回一个promise对象。但是在规范中，明确规定then方法返回的是一个新的promise对象，而不是直接返回的this。<br>并且then方法还需要判断当前状态，如果当前状态不是pending状态，那么可以直接调用传入的回调，不用再放入队列进行等待。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基础变量的定义</span></span><br><span class="line"><span class="keyword">const</span> STATUS = &#123;</span><br><span class="line">  PENDING: <span class="string">&#x27;PENDING&#x27;</span>,</span><br><span class="line">  FULFILLED: <span class="string">&#x27;FULFILLED&#x27;</span>,</span><br><span class="line">  REJECTED: <span class="string">&#x27;REJECTED&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> isFunction = <span class="function"><span class="params">fn</span> =&gt;</span> <span class="keyword">typeof</span> fn === <span class="string">&#x27;function&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Deferred</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">callback</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.value = <span class="literal">undefined</span></span><br><span class="line">    <span class="built_in">this</span>.status = STATUS.PENDING</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.resolveQueue = []</span><br><span class="line">    <span class="built_in">this</span>.rejectQueue = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> called <span class="comment">// 用于判断状态是否被修改</span></span><br><span class="line">    <span class="keyword">const</span> resolve = <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (called) <span class="keyword">return</span></span><br><span class="line">      called = <span class="literal">true</span></span><br><span class="line">      <span class="comment">// 异步调用</span></span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value</span><br><span class="line">        <span class="comment">// 修改状态</span></span><br><span class="line">        <span class="built_in">this</span>.status = STATUS.FULFILLED</span><br><span class="line">        <span class="comment">// 调用回调</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> fn <span class="keyword">of</span> <span class="built_in">this</span>.resolveQueue) &#123;</span><br><span class="line">          fn(<span class="built_in">this</span>.value)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> reject = <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (called) <span class="keyword">return</span></span><br><span class="line">      called = <span class="literal">true</span></span><br><span class="line">      <span class="comment">// 异步调用</span></span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = reason</span><br><span class="line">        <span class="comment">// 修改状态</span></span><br><span class="line">        <span class="built_in">this</span>.status = STATUS.REJECTED</span><br><span class="line">        <span class="comment">// 调用回调</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> fn <span class="keyword">of</span> <span class="built_in">this</span>.rejectQueue) &#123;</span><br><span class="line">          fn(<span class="built_in">this</span>.value)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      callback(resolve, reject)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error)&#123;</span><br><span class="line">      reject(error)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">then</span>(<span class="params">onResolve, onReject</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 解决值穿透</span></span><br><span class="line">    onResolve = isFunction(onResolve) ? onResolve : <span class="function"><span class="params">value</span> =&gt;</span> &#123; <span class="keyword">return</span> value &#125;</span><br><span class="line">    onReject = isFunction(onReject) ? onReject : <span class="function"><span class="params">reason</span> =&gt;</span> &#123; <span class="keyword">throw</span> reason &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.status === STATUS.PENDING) &#123;</span><br><span class="line">      <span class="comment">// 将回调放入队列中</span></span><br><span class="line">      <span class="keyword">const</span> rejectQueue = <span class="built_in">this</span>.rejectQueue</span><br><span class="line">      <span class="keyword">const</span> resolveQueue = <span class="built_in">this</span>.resolveQueue</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Deferred(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 暂存到成功回调等待调用</span></span><br><span class="line">        resolveQueue.push(<span class="function"><span class="keyword">function</span> (<span class="params">innerValue</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> value = OnResolve(innerValue)</span><br><span class="line">            <span class="comment">// 改变当前promise的状态</span></span><br><span class="line">            resolve(value)</span><br><span class="line">          &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">            reject(error)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="comment">// 暂存到失败回调等待调用</span></span><br><span class="line">        rejectQueue.push(<span class="function"><span class="keyword">function</span> (<span class="params">innerValue</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> value = onReject(innerValue)</span><br><span class="line">            <span class="comment">// 改变当前 promise 的状态</span></span><br><span class="line">            resolve(value)</span><br><span class="line">          &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">            reject(error)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> innerValue = <span class="built_in">this</span>.value</span><br><span class="line">      <span class="keyword">const</span> isFulfilled = <span class="built_in">this</span>.status === STATUS.FULFILLED</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Deferred(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">const</span> value = isFulfilled</span><br><span class="line">            ? onResolve(innerValue)</span><br><span class="line">            : onReject(innerValue)</span><br><span class="line">          resolve(value) <span class="comment">// 返回结果给后面的then</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">          reject(error)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果then直接就是返回了promise或者出现了循环引用怎么办？<br>前面在拿到了onResolve/onReject的返回值之后，就直接调用了resolve或reject，现在需要对返回值做一些处理。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基础变量的定义</span></span><br><span class="line"><span class="keyword">const</span> STATUS = &#123;</span><br><span class="line">  PENDING: <span class="string">&#x27;PENDING&#x27;</span>,</span><br><span class="line">  FULFILLED: <span class="string">&#x27;FULFILLED&#x27;</span>,</span><br><span class="line">  REJECTED: <span class="string">&#x27;REJECTED&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> isFunction = <span class="function"><span class="params">fn</span> =&gt;</span> <span class="keyword">typeof</span> fn === <span class="string">&#x27;function&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Deferred</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">callback</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.value = <span class="literal">undefined</span></span><br><span class="line">    <span class="built_in">this</span>.status = STATUS.PENDING</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.resolveQueue = []</span><br><span class="line">    <span class="built_in">this</span>.rejectQueue = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> called <span class="comment">// 用于判断状态是否被修改</span></span><br><span class="line">    <span class="keyword">const</span> resolve = <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (called) <span class="keyword">return</span></span><br><span class="line">      called = <span class="literal">true</span></span><br><span class="line">      <span class="comment">// 异步调用</span></span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value</span><br><span class="line">        <span class="comment">// 修改状态</span></span><br><span class="line">        <span class="built_in">this</span>.status = STATUS.FULFILLED</span><br><span class="line">        <span class="comment">// 调用回调</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> fn <span class="keyword">of</span> <span class="built_in">this</span>.resolveQueue) &#123;</span><br><span class="line">          fn(<span class="built_in">this</span>.value)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> reject = <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (called) <span class="keyword">return</span></span><br><span class="line">      called = <span class="literal">true</span></span><br><span class="line">      <span class="comment">// 异步调用</span></span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = reason</span><br><span class="line">        <span class="comment">// 修改状态</span></span><br><span class="line">        <span class="built_in">this</span>.status = STATUS.REJECTED</span><br><span class="line">        <span class="comment">// 调用回调</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> fn <span class="keyword">of</span> <span class="built_in">this</span>.rejectQueue) &#123;</span><br><span class="line">          fn(<span class="built_in">this</span>.value)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      callback(resolve, reject)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error)&#123;</span><br><span class="line">      reject(error)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">then</span>(<span class="params">onResolve, onReject</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 解决值穿透</span></span><br><span class="line">    onResolve = isFunction(onResolve) ? onResolve : <span class="function"><span class="params">value</span> =&gt;</span> &#123; <span class="keyword">return</span> value &#125;</span><br><span class="line">    onReject = isFunction(onReject) ? onReject : <span class="function"><span class="params">reason</span> =&gt;</span> &#123; <span class="keyword">throw</span> reason &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.status === STATUS.PENDING) &#123;</span><br><span class="line">      <span class="comment">// 将回调放入队列中</span></span><br><span class="line">      <span class="keyword">const</span> rejectQueue = <span class="built_in">this</span>.rejectQueue</span><br><span class="line">      <span class="keyword">const</span> resolveQueue = <span class="built_in">this</span>.resolveQueue</span><br><span class="line">      <span class="keyword">const</span> promise = <span class="keyword">new</span> Deferred(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 暂存到成功回调等待调用</span></span><br><span class="line">        resolveQueue.push(<span class="function"><span class="keyword">function</span> (<span class="params">innerValue</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> value = OnResolve(innerValue)</span><br><span class="line">            <span class="comment">// 改变当前promise的状态</span></span><br><span class="line">            doThenFunc(promise, value, resolve, reject)</span><br><span class="line">          &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">            reject(error)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="comment">// 暂存到失败回调等待调用</span></span><br><span class="line">        rejectQueue.push(<span class="function"><span class="keyword">function</span> (<span class="params">innerValue</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> value = onReject(innerValue)</span><br><span class="line">            <span class="comment">// 改变当前 promise 的状态</span></span><br><span class="line">            doThenFunc(promise, value, resolve, reject)</span><br><span class="line">          &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">            reject(error)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="keyword">return</span> promise</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> innerValue = <span class="built_in">this</span>.value</span><br><span class="line">      <span class="keyword">const</span> isFulfilled = <span class="built_in">this</span>.status === STATUS.FULFILLED</span><br><span class="line">      <span class="keyword">const</span> promise = <span class="keyword">new</span> Deferred(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">const</span> value = isFulfilled</span><br><span class="line">            ? onResolve(innerValue)</span><br><span class="line">            : onReject(innerValue)</span><br><span class="line">          resolve(value) <span class="comment">// 返回结果给后面的then</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">          reject(error)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="keyword">return</span> promise</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doThenFunc</span>(<span class="params">promise, value, resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 循环引用</span></span><br><span class="line">  <span class="keyword">if</span> (promise === value) &#123;</span><br><span class="line">    reject(</span><br><span class="line">      <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;Chaining cycle detected for promise&#x27;</span>)</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果value是promise对象</span></span><br><span class="line">  <span class="keyword">if</span> (value <span class="keyword">instanceof</span> Deferred) &#123;</span><br><span class="line">    <span class="comment">// 调用then，等待结果</span></span><br><span class="line">    value.then(</span><br><span class="line">      <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">        doThenFunc(promise, val, resolve, reject)</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="function"><span class="keyword">function</span> (<span class="params">reason</span>) </span>&#123;</span><br><span class="line">        reject(reason)</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果value非promise对象</span></span><br><span class="line">  resolve(value)</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h1 id="catch方法"><a href="#catch方法" class="headerlink" title="catch方法"></a>catch方法</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Deferred</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">callback</span>)</span> &#123;&#125;</span><br><span class="line">  <span class="function"><span class="title">then</span>(<span class="params">onResolve, onReject</span>)</span> &#123;&#125;</span><br><span class="line">  <span class="keyword">catch</span>(onReject) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.then(<span class="literal">null</span>, onReject)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h1><h2 id="resolve-reject"><a href="#resolve-reject" class="headerlink" title="resolve/reject"></a>resolve/reject</h2><p>Promise提供resolve/reject两个方法直接返回状态已经固定的promise对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Deferred</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">callback</span>)</span> &#123;&#125;</span><br><span class="line">  <span class="function"><span class="title">then</span>(<span class="params">onResolve, onReject</span>)</span> &#123;&#125;</span><br><span class="line">  <span class="keyword">catch</span>(onReject) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">resolve</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Deferred(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      resolve(value)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">reject</span>(<span class="params">reason</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Deferred(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      reject(reason)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="all"><a href="#all" class="headerlink" title="all"></a>all</h2><p>all方法接受一个promise对象组成的数组，等数组中的所有promise对象的状态变为fulfilled返回结果。结果也为数组，每个值对应的是promise对象的内部结果。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Deferred</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">all</span>(<span class="params">promises</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 非数组参数，抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(promises)) &#123;</span><br><span class="line">      <span class="keyword">return</span> Deferred.reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;args must be an array&#x27;</span>))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> result = []</span><br><span class="line">    <span class="keyword">const</span> length = promises.length</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> remaining = length</span><br><span class="line">    <span class="keyword">const</span> promise = <span class="keyword">new</span> Deferred(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 如果数组为空，返回空结果</span></span><br><span class="line">      <span class="keyword">if</span> (length === <span class="number">0</span>) <span class="keyword">return</span> resolve(result)</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">done</span>(<span class="params">index, value</span>) </span>&#123;</span><br><span class="line">        doThenFunc(</span><br><span class="line">          promise,</span><br><span class="line">          value,</span><br><span class="line">          val =&gt; &#123;</span><br><span class="line">            result[index] = val</span><br><span class="line">            <span class="keyword">if</span> (--remaining === <span class="number">0</span>) &#123;</span><br><span class="line">              resolve(result)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          reject</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 放入异步队列</span></span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">          done(i, promise[i])</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> promise</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="race"><a href="#race" class="headerlink" title="race"></a>race</h2><p>race 方法同样接受一个 promise 对象的数组，但是它只需要有一个 promise 变为 fulfilled 状态就会返回结果。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Deferred</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">race</span>(<span class="params">promises</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 非数组参数，抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(promises)) &#123;</span><br><span class="line">      <span class="keyword">return</span> Deferred.reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;args must be an array&#x27;</span>))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> length = promises.length</span><br><span class="line">    <span class="keyword">const</span> promise = <span class="keyword">new</span> Deferred(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 如果数组为空，返回空结果</span></span><br><span class="line">      <span class="keyword">if</span> (length === <span class="number">0</span>) <span class="keyword">return</span> resolve([])</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">done</span>(<span class="params">index, value</span>) </span>&#123;</span><br><span class="line">        doThenFunc(promise, value, resolve, reject)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 放入异步队列</span></span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">          done(i, promise[i])</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> promise</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>虚拟DOM简介</title>
    <url>/2021/01/23/%E8%99%9A%E6%8B%9FDOM%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h2 id="什么是虚拟DOM"><a href="#什么是虚拟DOM" class="headerlink" title="什么是虚拟DOM"></a>什么是虚拟DOM</h2><p>在程序运行时，状态会不断发生变化。每当状态发生变化时，都需要重新渲染。如何确定状态中发生了什么变化以及需要在哪里更新DOM？<br>在这种情况下，最简单粗暴的解决方式是，既不需要关心状态发生了什么变化，也不需要关心在哪里更新DOM，只需要把所有DOM全删 ，然后使用状态重新生成一份DOM，并将其输出到页面上显示出来就好了。<br>但是访问DOM是非常昂贵的。按照上面说的方式做，会造成相当多的性能浪费。状态变化通常只有有限的几个节点需要重新渲染，所以我们不仅需要找出哪里需要更新，还需要尽可能少地访问DOM。<br>这个问题有很多种解决方案。在Angular就是脏检查的流程，React中使用虚拟DOM。因此，虚拟DOM本质上只是众多解决方案中的一种，可以用但并不一定必须用。<br>虚拟DOM的解决方式是通过状态生成一个虚拟节点树，然后使用虚拟节点树进行渲染。在渲染之前，会使用新生成的虚拟节点树和上一次生成的虚拟节点树进行对比，只渲染不用的部分。<br>虚拟节点树其实是由组件树建立起来的整个虚拟节点（Virtual Node，也经常简写为vnode）树。</p>
<h2 id="为什么要引入虚拟DOM"><a href="#为什么要引入虚拟DOM" class="headerlink" title="为什么要引入虚拟DOM"></a>为什么要引入虚拟DOM</h2><p>Angular和React的变化侦测有一个共同点，那就是它们都不知道哪些状态变了。因此，就需要进行比较暴力的比对，React是通过虚拟DOM的比对，Angular是使用脏检查的流程。<br>Vue.js的变化侦测和它们都不一样，可以在一定程度知道具体哪些状态发生了变化。Vue.js2.0开始引入了虚拟DOM。组件级别是一个watcher实例，就是说即便一个组件内有10个节点使用了某个状态，但其实也只有一个watcher在观察这个状态的变化。所以当这个状态发生变化时，只能通知到组件，然后组件内部通过虚拟DOM去进行比对与渲染。</p>
<h2 id="Vue-js中的虚拟DOM"><a href="#Vue-js中的虚拟DOM" class="headerlink" title="Vue.js中的虚拟DOM"></a>Vue.js中的虚拟DOM</h2><p>在Vue中，我们使用模版来描述状态与DOM之间的映射关系。Vue通过编译将模版转换成渲染函数（render），执行渲染函数就可以得到一个虚拟节点树，使用这个虚拟节点树就可以渲染页面。<br>虚拟DOM的目标是将虚拟节点渲染到试图上。但是如果直接使用虚拟节点覆盖旧节点，会有很多不必要的DOM操作。为了避免不必要的DOM操作，虚拟DOM在虚拟节点映射到试图的过程中，将虚拟节点与上一次渲染视图所使用的就虚拟节点做对比，找出真正需要更新的节点来进行DOM操作，从而避免操作其他无任何改动的DOM。</p>
]]></content>
      <categories>
        <category>深入浅出Vue. js</category>
      </categories>
  </entry>
  <entry>
    <title>CSS</title>
    <url>/2021/03/04/CSS/</url>
    <content><![CDATA[<h1 id="两种盒模型分别说一下？"><a href="#两种盒模型分别说一下？" class="headerlink" title="两种盒模型分别说一下？"></a>两种盒模型分别说一下？</h1><p>CSS盒模型本质上是一个盒子，盒子包裹着HTML元素，盒子由四个属性组成，从内到外分别是：content、padding、border、margin。</p>
<h2 id="盒模型的分类"><a href="#盒模型的分类" class="headerlink" title="盒模型的分类"></a>盒模型的分类</h2><p>两种盒模型分别是：</p>
<ul>
<li>W3C盒子模型（标准盒模型）</li>
<li>IE盒子模型（怪异盒模型）</li>
</ul>
<h2 id="两种盒模型的区别"><a href="#两种盒模型的区别" class="headerlink" title="两种盒模型的区别"></a>两种盒模型的区别</h2><p>宽度和高度的计算方式不同</p>
<p>标准盒模型：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">width = content-width</span><br><span class="line">height = content-height</span><br></pre></td></tr></table></figure>
<p>怪异盒模型：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">width = content-width + padding-width + border-width</span><br><span class="line">height = content-height + padding-height + border-height</span><br></pre></td></tr></table></figure>
<h2 id="如何设置这两个类型"><a href="#如何设置这两个类型" class="headerlink" title="如何设置这两个类型"></a>如何设置这两个类型</h2><p>标准盒模型</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">box-sizing</span>: <span class="selector-tag">content-box</span></span><br></pre></td></tr></table></figure>
<p>怪异盒模型</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">box-sizing</span>: <span class="selector-tag">border-box</span></span><br></pre></td></tr></table></figure>
<h1 id="如何垂直居中？"><a href="#如何垂直居中？" class="headerlink" title="如何垂直居中？"></a>如何垂直居中？</h1><ul>
<li>使用table自带功能</li>
<li>给child设置before、after，设置为高度100%、inline-block，给parent设置text-align：center；（parent需要设置高度，child需要设置宽度）</li>
<li>div装table</li>
<li>使用-margin：把parent相对定位，child绝对定位，设置left：50%；top：50%；然后设置-margin-top为child高度的一半，-margin-left为宽度的一半。（child需要设置高度和宽度）</li>
<li>使用transform：把parent相对定位，child绝对定位，设置left：50%；top：50%；然后设置transform: translate(-50%,-50%);（无需确定子元素高度宽度）</li>
<li>使用margin：auto；：把parent相对定位，child绝对定位，设置left：0；top：0；right：0；bottom：0；然后设置margin：auto；</li>
<li>flex布局：parent设置display: flex;justify-content: center;align-items: center;</li>
</ul>
<h1 id="flex怎么用？常用属性有哪些？"><a href="#flex怎么用？常用属性有哪些？" class="headerlink" title="flex怎么用？常用属性有哪些？"></a>flex怎么用？常用属性有哪些？</h1><p>flex用法：设置display为flex或者inline-flex。（设置为flex布局以后，子元素的float、clear、vertical-align属性将失效）</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>采用Flex布局的元素称为Flex 容器（flex container）。它的所有子元素自动成为容器成员，成为Flex 项目（flex item）。<br>容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。<br>项目默认沿主轴排列。</p>
<h2 id="容器的属性"><a href="#容器的属性" class="headerlink" title="容器的属性"></a>容器的属性</h2><ul>
<li><a href="#flex-direction%E5%B1%9E%E6%80%A7">flex-direction属性</a></li>
<li><a href="#flex-wrap%E5%B1%9E%E6%80%A7">flex-wrap属性</a></li>
<li><a href="#flex-flow%E5%B1%9E%E6%80%A7">flex-flow属性</a></li>
<li><a href="#justify-content%E5%B1%9E%E6%80%A7">justify-content属性</a></li>
<li><a href="#align-items%E5%B1%9E%E6%80%A7">align-items属性</a></li>
<li><a href="#align-content%E5%B1%9E%E6%80%A7">align-content属性</a></li>
</ul>
<h3 id="flex-direction属性"><a href="#flex-direction属性" class="headerlink" title="flex-direction属性"></a>flex-direction属性</h3><p>flex-direction属性决定主轴的方向（即项目的排列方向）</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">flex-direction</span>: row | row-reverse | column | column-reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它可能有4个值。</p>
<ul>
<li>row（默认值）：主轴为水平方向，起点在左端</li>
<li>row-reverse：主轴为水平方向，起点在右端</li>
<li>column：主轴为垂直方向，起点在上沿</li>
<li>column-reverse：主轴为垂直方向，起点在下沿</li>
</ul>
<h3 id="flex-wrap属性"><a href="#flex-wrap属性" class="headerlink" title="flex-wrap属性"></a>flex-wrap属性</h3><p>默认情况下，项目都排在一条线（又称“轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">flex-wrap</span>: nowrap | wrap | wrap-reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它可能取三个值。</p>
<ul>
<li>nowrap（默认）：不换行。</li>
<li>wrap：换行，第一行在上方。</li>
<li>wrap-reverse：换行，第一行在下方。</li>
</ul>
<h3 id="flex-flow属性"><a href="#flex-flow属性" class="headerlink" title="flex-flow属性"></a>flex-flow属性</h3><p>flex-flow属性是flex-direction属性与flex-wrap属性的简写形式，默认值为row nowrap。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">flex-flow</span>: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="justify-content属性"><a href="#justify-content属性" class="headerlink" title="justify-content属性"></a>justify-content属性</h3><p>justify-content属性定义了项目在主轴上的对齐方式。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">justify-content</span>: flex-start | flex-end | center | space-between | space-around;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它可能取五个值，具体对齐方式与轴的方向有关。下面假设主轴从左到右。</p>
<ul>
<li>flex-start（默认值）：左对齐</li>
<li>flex-end：右对齐</li>
<li>center：居中</li>
<li>space-between：两端对齐，项目之间的间隔都相等</li>
<li>space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍</li>
</ul>
<h3 id="align-items属性"><a href="#align-items属性" class="headerlink" title="align-items属性"></a>align-items属性</h3><p>align-items属性定义项目在交叉轴上如何对齐。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">align-items</span>: flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它可能取五个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。</p>
<ul>
<li>flex-start：交叉轴的起点对齐</li>
<li>flex-end：交叉轴的终点对齐</li>
<li>center：交叉轴的中点对齐</li>
<li>baseline：项目的第一行文字的基线对齐</li>
<li>stretch（默认值）：如果项目为设置高度或者设置为auto，将占满整个容器的高度</li>
</ul>
<h3 id="align-content属性"><a href="#align-content属性" class="headerlink" title="align-content属性"></a>align-content属性</h3><p>align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，则该属性不起作用。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">align-content</span>: flex-start | flex-end | center | space-between | space-around | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该属性可能取六个值。</p>
<ul>
<li>flex-start：与交叉轴起点对齐</li>
<li>flex-end：与交叉轴终点对齐</li>
<li>center：与交叉轴的中点对齐</li>
<li>space-between：与交叉轴两端对齐，轴线之间间隔平均分布</li>
<li>space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍</li>
<li>stretch（默认值）:轴线占满整个交叉轴</li>
</ul>
<h2 id="项目的属性"><a href="#项目的属性" class="headerlink" title="项目的属性"></a>项目的属性</h2><ul>
<li><a href="#order%E5%B1%9E%E6%80%A7">order属性</a></li>
<li><a href="#flex-grow%E5%B1%9E%E6%80%A7">flex-grow属性</a></li>
<li><a href="#flex-shrink%E5%B1%9E%E6%80%A7">flex-shrink属性</a></li>
<li><a href="#flex-basis%E5%B1%9E%E6%80%A7">flex-basis属性</a></li>
<li><a href="#flex%E5%B1%9E%E6%80%A7">flex属性</a></li>
<li><a href="#align-self%E5%B1%9E%E6%80%A7">align-self</a></li>
</ul>
<h3 id="order属性"><a href="#order属性" class="headerlink" title="order属性"></a>order属性</h3><p>order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">order</span>: &lt;integer&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="flex-grow属性"><a href="#flex-grow属性" class="headerlink" title="flex-grow属性"></a>flex-grow属性</h3><p>flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex-grow</span>: &lt;number&gt;; <span class="comment">/* default 0 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="flex-shrink属性"><a href="#flex-shrink属性" class="headerlink" title="flex-shrink属性"></a>flex-shrink属性</h3><p>flex-shrink属性定义项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex-shrink</span>: &lt;number&gt;; <span class="comment">/* default 1 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="flex-basis属性"><a href="#flex-basis属性" class="headerlink" title="flex-basis属性"></a>flex-basis属性</h3><p>flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间。它的默认值为auto，即项目的本来大小。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex-basis</span>: &lt;length&gt; | auto; <span class="comment">/* default auto */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它可以设为跟width或height属性一样的值，则项目将占据固定空间。</p>
<h3 id="flex属性"><a href="#flex属性" class="headerlink" title="flex属性"></a>flex属性</h3><p>flex属性是flex-grow属性、flex-shrink属性和flex-basis属性的简写。默认值为0 1 auto。后两个属性可选。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: none | [ &lt;<span class="string">&#x27;flex-grow&#x27;</span>&gt; &lt;<span class="string">&#x27;flex-shrink&#x27;</span>&gt;? || &lt;<span class="string">&#x27;flex-basis&#x27;</span>&gt; ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该属性有两个快捷值：auto（1 1 auto）和 none（0 0 auto）</p>
<h3 id="align-self属性"><a href="#align-self属性" class="headerlink" title="align-self属性"></a>align-self属性</h3><p>align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">align-self</span>: auto | flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="BFC是什么？"><a href="#BFC是什么？" class="headerlink" title="BFC是什么？"></a>BFC是什么？</h1><p>块格式化上下文（Block Formatting Context， BFC）是Web页面的可视CSS渲染的一部分，是块盒子的布局过程发生的区域，也是浮动元素与其他元素发生交互的区域。<br>块格式化上下文包含创建它的元素内部的所有内容。</p>
<h1 id="清除浮动代码。"><a href="#清除浮动代码。" class="headerlink" title="清除浮动代码。"></a>清除浮动代码。</h1><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">clear</span>: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>面试题</category>
      </categories>
  </entry>
  <entry>
    <title>模版编译</title>
    <url>/2021/02/08/%E6%A8%A1%E7%89%88%E7%BC%96%E8%AF%91/</url>
    <content><![CDATA[<p>Vue提供了模版语法，允许我们声明式地描述状态和DOM之间的绑定关系，然后通过模版来生成真实DOM并将其呈现在用户界面上。<br>在底层实现上，Vue会将模版编译成虚拟DOM渲染函数。当应用内部状态发生变化时，Vue可以结合响应式系统，找出最小数量的组件进行重新渲染以及最少量地进行DOM操作。</p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>平时使用模版时，可以在模版中使用一些变量来填充模版，还可以在模版中使用js表达式，又或者是使用一些指令等。<br>这些功能在HTML语法中是不存在的，为什么在Vue的模版中就可以使用呢？这就多亏了模版编译赋予了模版强大的功能。<br>模版编译的主要目标就是生成渲染函数。而渲染函数的作用是每次执行它，就会使用当前最新的状态生成一份新的vnode，然后使用这个vnode进行渲染。</p>
<h2 id="将模版编译成渲染函数"><a href="#将模版编译成渲染函数" class="headerlink" title="将模版编译成渲染函数"></a>将模版编译成渲染函数</h2><p>将模版编译成渲染函数可以分两个步骤，先将模版解析成AST，然后再使用AST生成渲染函数。<br>但是由于静态节点不需要总是重新渲染，所以在生成AST之后，生成渲染函数之前这个阶段，需要做一个操作，那就是遍历一遍AST，给所有静态节点做一个标记，这样在虚拟DOM中更新节点时，如果发现节点有这个标记，就不会重新渲染它。<br>所以，在大体逻辑上，模版编译分为三部分内容：</p>
<ul>
<li>将模版解析为AST</li>
<li>遍历AST标记静态节点</li>
<li>使用AST生成渲染函数</li>
</ul>
<p>这三部分内容在模版编译中分别抽象出三个模块来实现各自的功能，分别是：</p>
<ul>
<li>解析器</li>
<li>优化器</li>
<li>代码生成器</li>
</ul>
<h3 id="解析器"><a href="#解析器" class="headerlink" title="解析器"></a>解析器</h3><p>解析器的目标很明确，只实现一个功能，那就是将模版解析成AST。<br>在解析器内部，分成了很多小解析器，其中包括过滤器解析器、文本解析器和HTML解析器。然后通过一条主线将这些解析器组装在一起。<br>在使用模版时，我们可以在其中使用过滤器，而过滤器解析器的作用就是用来解析过滤器的。<br>文本解析器的主要作用是用来解析带变量的文本。<br>最后是最重要的HTML解析器，它是解析器中最核心的模块，它的作用就是解析模块，每当解析到HTML标签的开始位置、结束位置、文本或注释时，都会触发钩子函数，然后将相关信息通过参数传递出来。<br>主线上做的事就是监听HTML解析器。每当触发钩子函数时，就生成一个对应的AST节点。生成AST前，会根据类型使用不同的方式生成不同的AST。例如，如果是文本节点，就生成文本类型的AST。<br>这个AST和vnode有点类似，都是使用js中的对象来表示节点。<br>当HTML解析器把所有模块都解析完毕后，AST也就生成好了。</p>
<h3 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h3><p>优化器的目标是遍历AST，检测出所有静态子树并给其打标记。<br>当AST中的静态子树被打上标记后，每次重新渲染时，就不需要为打上标记的静态节点创建新的虚拟节点，而是直接克隆已存在的虚拟节点。在虚拟DOM的更新操作中，如果发现两个节点是同一个节点，正常情况下会对这两个节点进行更新，但是如果这两个节点是静态节点，则可以直接跳过更新节点的流程。<br>总体来说，优化器的主要作用是避免一些无用功来提升性能。因为静态节点除了首次渲染，后续不需要任何重新渲染操作。</p>
<h3 id="代码生成器"><a href="#代码生成器" class="headerlink" title="代码生成器"></a>代码生成器</h3><p>代码生成器是模版编译的最后一步，它的作用是将AST转换成渲染函数中的内容，这个内容可以称为“代码字符串”。<br>代码字符串最终导出到外界使用时，会将代码字符串放到函数里，这个函数叫做渲染函数。</p>
]]></content>
      <categories>
        <category>深入浅出Vue. js</category>
      </categories>
  </entry>
</search>
